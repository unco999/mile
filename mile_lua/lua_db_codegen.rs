use mlua::{Lua, Table, Value};
use std::{
    collections::BTreeMap,
    error::Error,
    fmt::Write as _,
    path::Path,
    sync::{Arc, Mutex},
};

#[derive(Clone, Debug)]
struct RegisteredField {
    name: String,
    ty: FieldType,
}

#[derive(Clone, Debug)]
enum FieldType {
    Bool,
    Integer,
    Number,
    String,
    Struct(String),
}

#[derive(Clone, Debug)]
struct RegisteredType {
    name: String,
    fields: Vec<RegisteredField>,
}

pub fn generate_types(dir: &Path) -> Result<String, Box<dyn Error>> {
    let registry: Arc<Mutex<BTreeMap<String, RegisteredType>>> =
        Arc::new(Mutex::new(BTreeMap::new()));
    collect_registered_types(dir, &registry)?;
    let types = registry
        .lock()
        .expect("registry poisoned")
        .clone();
    Ok(render_types(&types))
}

fn collect_registered_types(
    dir: &Path,
    registry: &Arc<Mutex<BTreeMap<String, RegisteredType>>>,
) -> Result<(), Box<dyn Error>> {
    let lua = Lua::new();

    {
        let registry_ptr = registry.clone();
        let register_fn = lua.create_function(move |lua, (name, table): (String, Table)| {
            parse_table(lua, name, &table, &registry_ptr)
                .map_err(|e| mlua::Error::external(e.to_string()))?;
            Ok(())
        })?;
        lua.globals().set("register_db_type", register_fn)?;
    }

    walk_lua_files(dir, &mut |path| -> Result<(), Box<dyn Error>> {
        let source = std::fs::read_to_string(path)?;
        let chunk = lua
            .load(&source)
            .set_name(path.to_string_lossy().into_owned());
        chunk.exec()?;
        Ok(())
    })?;

    Ok(())
}

fn walk_lua_files(
    dir: &Path,
    f: &mut dyn FnMut(&Path) -> Result<(), Box<dyn Error>>,
) -> Result<(), Box<dyn Error>> {
    if !dir.exists() {
        return Ok(());
    }
    for entry in std::fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            walk_lua_files(&path, f)?;
        } else if path.extension().is_some_and(|ext| ext == "lua") {
            f(&path)?;
        }
    }
    Ok(())
}

fn parse_table(
    lua: &Lua,
    name: String,
    table: &Table,
    registry: &Arc<Mutex<BTreeMap<String, RegisteredType>>>,
) -> Result<(), Box<dyn Error>> {
    let mut registry_guard = registry
        .lock()
        .expect("register_db_type registry poisoned");
    let mut fields = Vec::new();
    for pair in table.pairs::<Value, Value>() {
        let (key, value) = pair?;
        let field_name = match key {
            Value::String(s) => s.to_string_lossy().to_string(),
            Value::Integer(i) => format!("field_{i}"),
            Value::Number(n) => format!("field_{n}"),
            other => format!("field_{}", sanitize_ident(&format!("{other:?}"))),
        };
        let ty = match value {
            Value::Boolean(_) => FieldType::Bool,
            Value::Integer(_) => FieldType::Integer,
            Value::Number(_) => FieldType::Number,
            Value::String(_) => FieldType::String,
            Value::Table(t) => {
                drop(registry_guard);
                let nested_name = format!("{}_{}", name, to_pascal_case(&field_name));
                parse_table(lua, nested_name.clone(), &t, registry)?;
                registry_guard = registry
                    .lock()
                    .expect("register_db_type registry poisoned");
                FieldType::Struct(nested_name)
            }
            Value::Nil => FieldType::String,
            other => {
                return Err(format!(
                    "register_db_type field {} unsupported value {:?}",
                    field_name, other
                )
                .into())
            }
        };
        fields.push(RegisteredField {
            name: field_name,
            ty,
        });
    }
    let field_count = fields.len();
    println!(
        "[lua_db_codegen] register_db_type '{}' (fields: {field_count})",
        name
    );
    registry_guard.insert(
        name.clone(),
        RegisteredType { name, fields },
    );
    Ok(())
}

fn render_types(types: &BTreeMap<String, RegisteredType>) -> String {
    let mut out = String::new();
    writeln!(
        &mut out,
        "// @generated by mile_lua build script\n"
    )
    .unwrap();
    for ty in types.values() {
        writeln!(
            &mut out,
            "#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, Default)]"
        )
        .unwrap();
        writeln!(&mut out, "pub struct {} {{", ty.name).unwrap();
        for field in &ty.fields {
            let ident = sanitize_ident(&field.name);
            let ty_name = match &field.ty {
                FieldType::Bool => "bool".to_string(),
                FieldType::Integer => "i64".to_string(),
                FieldType::Number => "f64".to_string(),
                FieldType::String => "String".to_string(),
                FieldType::Struct(name) => name.clone(),
            };
            writeln!(&mut out, "    pub {ident}: {ty_name},").unwrap();
        }
        writeln!(&mut out, "}}\n").unwrap();
    }
    if types.is_empty() {
        out.push_str("// no types registered\n");
    }
    out
}

fn to_pascal_case(value: &str) -> String {
    value
        .split(|c: char| !c.is_alphanumeric())
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                None => String::new(),
            }
        })
        .collect()
}

fn sanitize_ident(value: &str) -> String {
    let mut ident = String::new();
    for (idx, ch) in value.chars().enumerate() {
        if idx == 0 && !ch.is_ascii_alphabetic() && ch != '_' {
            ident.push('_');
        }
        if ch.is_ascii_alphanumeric() || ch == '_' {
            ident.push(ch.to_ascii_lowercase());
        } else {
            ident.push('_');
        }
    }
    if ident.is_empty() {
        "_field".into()
    } else {
        ident
    }
}
